# abz.agency test application.

## Проблемы с постановкой задачи (TROUBLESHOOTING):

1. Навигация:
    1.1. На экрана **No Connection** присутствует кнопка **Try again**. Эта кнопка имеет смысл только в том случае, если пользователю необходимо в ручном режиме делать подключение к серверу сохраняющем состояние (например, **WebSocket**). Поскольку REST сервер состояние не хранит, то для него отсутствует понятие подключение. А следовательно, он должен реагировать на изменение доступности к сети интернет. Следовательно, доступность отслеживается самим приложением, поэтому нажатие на кнопку пользователем **УЖЕ** не имеет смысла - если internet недоступен, то нажатие ни к чему не приведет. А если интернет доступен - то приложением будет об этом знать раньше пользователя, и поменяет свое состояние.
    1.2. В фигме навигация приложения прорисована в зачаточном состоянии, из-за этого архитектура навигации не может быть сформирована в полной мере: либо она буде избыточна для приложения, либо недостаточно масштабируемая в случае дальнейшей разработки приложения.
    1.3. На экранах success и fail крестик дублирует основную кнопку. Причем, согласно логике использования UI они должны выполнять диаметрально противоположные функции.

2. На экране с перечнем списка пользователей предполагается отображение в определенном порядке, и одновременно с этим, использованием паджинации:
    2.1 Использование паджинации являтся признаком дурного тона для мобильных приложений, хотя допускается такое поведение для Web сайтов. Мобильное приложение не должно работать с онлайн данными. Вместо этого, оно формирует коллекцию в персистивном хранилище, и отображает данные из него. Одновременно с этим осуществляет запрос для получения новых порций данных. После формирования списка, данные отображаются на экране в нужном порядке. Весь процесс происходит без участия пользователя. Данные доступны для автономной работы. В соотвествии с постановкой задачи данные подгружаются последовательно, как реакция на действия пользователя.
    2.2. Если данные отображаются из локального хранилища - то они будут иметь строгую последовательность. В случае загрузки данных через паджинацию, могут быть получены данные, которые не соответствуют фрейму текущей сортировки, и, следовательно, пользователь их не увидит.
    
3. На экране Sign-Up присутствует элемент Radio-button - он **НЕ РЕКОМЕНДУЕТСЯ** к использованию для приложений iOS SDK компанией Apple. Вместо **рекомендуется** использовать выборщики или таблицы.

4.  На экране Sign-Up присутствует нередактируемое поле ввода для загрузки изображения.
    4.1. Что, по мнению, дизайнера должно отображаться в нем после загрузки аватара? В фигме нет на это никаких указаний.
    4.2. Было бы логичней показать плейсходер аватара, пока аватар не загружен, и загруженное изображение, если файл передан на сервер.

5. Модель данных для загрузка списка пользователей - избыточна.

6. Модель данных негативных ответов сервера архитектурно неправильна:
    6.1. HTTP  статусы в ней смешаны с бизнес логикой. Такой прием используется, если ответы приходят не от REST сервера приложения, а от веб-сервера, хостящего web-site и не имеющего возможности обрабатывать сложую бизнес логику на стороне сервера.
    6.2. Негативные статусы не имеют строгой модели данных, из-за этого, каждый запрос имеет набор возможных негативных ответов, что приводит к необоснованному усложнению бизнес-логики нетвокинга на стороне клиента, в то время, как за стояние и структуру данных ответственность несет сервер. Т.е. присутствует ситуацию перекладывания ответственности.
    6.3. Если запрос вышел за пределы существующего диапазона - клиент получает 404 HTTP  status. Это абсолютно неправильно, исходя из формата успешного ответа, в котором пользователь получает ссылку на предыдущую успешную страницу загрузки. Было бы логичнее, в случае выхода за пределы диапазона, отдавать пустой массив.
    6.4. REGEX для проверки номера телефона на стороне сервера не соответствует маске, предлагаемой для ввода пользователя на клиенте.

7. Ресурсы в фигме и верстка
    7.1. Изображение в фигме имеют неправильные повторяющиеся имена. К примеру, success-image.
    7.2. Для iOS предлагается сделать SVG импорт, вместо  PDF.
    7.3. Отсутствует 1024x1024  изображение для экспорта значка приложения.
    7.4. Неполная цветовая палитра:
        - отсутствует цвет надписей (черный) (имеет несколько градаций прозрачности).
        - отсутствует цвет выбранной Primary кнопки.
        - отсутствует цвет disabled Primary кнопки.
        - отсутствует цвет ошибки.
    7.5. Отсуствуют внятные определения шрифта:
    - используется кастомный шрифт Nunito Sans.
    - отсутствует доступ для получение атрибутов шрифта в формате iOS SDK.
    7.6. Верстка не содержит мокапов для резолюций, содержащих монобровь или остров.


8. Сообщение вида **Required field** на экране SignUp бессмысленно, при условии, что кнопка отправки данных Disable при незаполненных полях.

## РЕАЛИЗАЦИЯ:

1. Созданы два варианта приложения: abzV1 и abzV2.
    abzV1 - имеет реализацию в текущей постановке задачи, с хранением данных в памяти. Соотвественно, весь набор данных сбрасывается при перезапуске приложения. В этом варианте реализована дозагрузка данных по мере пролистывания данных пользователем. В момент загрузки отображается индикатор активности в нижней части списка пользователей. Загрузка происходит по 5 пользователей на странице. Если сетевое подключения отсутствует в момент запуска приложения, пользователь увидит плейсхолдер в списке пользователей. 
    abzV2 - в своей основе имеет CoreData, соответственно, все ранее загруженные данные сохраняются в персистивном хранилище, и сразу доступны для просмотра при перезапуске приложения. Данные загружаются в фоновом режиме без участия пользователя. При перезапуске приложения происходит обновление данных. В момент, когда данные обновились, они становятся видимы пользователю. Для пользователя этот процесс происходит незаметно. Все данные доступны для просмотра, даже если приложение было запущено без сетевого подключения.
    
2. Доступность сетевого подключения:
    Реализован механизм уведомления пользователя об отсутствии сетевого подключения без участия пользователя.
    Когда обнаруживается потеря сетевого подключения отображается необходимый экран. После возвращения сетевого подключения экран автоматически убирается. Временной фрейм детекции составляет 5 секунд. Пользователь может самостоятельно закрыть экран уведомления и продолжить работу с приложением в автономном режиме.
    
3. Навигация:
    В приложениях реализована навигация на основе состояний. С точки зрения iOS разработки такой тип навигации допустим, но неправилен. Однако, в силу примитивности приложения внедрение полноценной навигации представляется избыточной.
    
4. Шрифты:
    В постановке задачи используется кастомный шрифт, отсутствующий  среди шрифтов платформы. Поскольку полноценного доступа к dev mode Figma отсутствует, а так же, поскольку стандартный системный шрифт схож с заявленным в фигме, то было принято решение об использовании системного шрифта с атрибутами, доступными для работы в фигме.
    
5. Конфигурация сети:
        Настройка сетевого подключения содержится в файле RestNetworkProvider.swift. 
        Целесообразно было бы вынести их в конфигурационный файл Info.plist или файл Pkl.

6. REST networking:
    Использован паттерн Command для реализации сетевого взаимодействия. Детали можно посмотреть в статье: https://habr.com/ru/articles/697262/
    
7. Concurrency:
    Сетевое взаимодействие, доступ к базе данных и некоторые другие операции внутри приложения используют асинхронную многопоточность (async), механизм доступный в Swift, начиная с версии Swift 5.5. Networking Reachability основан на GDC. 

8. Персистивное хранилище:
    Приложение abzV2  использует ORM CoreData в режиме работы с базой данных SQLite. Все взаимодействия с хранилищем происходят в фоновом режиме. Каждое взаимодействие обернуто в ACID транзакцию. Транзакции обеспечены контекстом CoreData. Все читаемые данные доступны исключительно в Codable формате, т.е. UI приложения работает с "устойчивой" формой данных. Извлечение данных списка происходит через FetchController. FetchController позволяет извлекать данные с помощью предиката, но в текущем приложении предикатный доступ незадействован. Однако, сортировка происходит на уровне SQL (abzV1 делает сортировку в фоновом режиме предикатами Swift). Передача излеченных данных в  UI осуществляется путем взаимодействия с библиотекой Combine. Для логгирования внутренних процеccов производится при помощи асинхронных каналов (AsyncChannel) которые стали доступны начиная с версии Swift 5.9.
    
9. Зависимости:
    Используется SPM v2 в качестве механизма управления зависимостями.
    К внешним (ThirdParty) библиотекам относится библиотека Kingfisher, которая обеспечивает асинхронную загрузку и отображения изображений по URL ссылке: https://github.com/onevcat/Kingfisher
    К внутренние зависимостям относится библиотека AsyncAlgorithms, которая обеспечивает реализацию AsyncChannel: https://github.com/apple/swift-async-algorithms
    Так же, происходит автоматическая загрузка зависимой библиотеки SwiftCollection: https://swift.org/blog/swift-collections
    Внутренние зависимости использует только приложение abzV2.

10. Сборка приложения (Это обязательный пункт, который был указан в ТЗ):
     Сборка происходит естественный образом, путем нажатия на кнопку Run в XCode, при условии, что все зависимости установлены и обновлены. Обновление зависимостей, как правило, происходит без участия пользователя, сразу после запуска XCode.

11. Структура кода:
    Структура полностью отражена в дереве проекта:
        - Core: содержит весь исходный код приложения
            - Extensions - расширение объектов Swift
            - Model - Codable, Uncodable и Management модели данных. В случае, когда речь идет об объектах CoreData (для abzV2) в модели данных относятся:
                    - Схема CoreData
                    - Расширение сущностей, унаследованных от IEntity.
                    - Объекты фетчеры, которые извлекают и трансфоормируют данные из персистивного хранилища.
            - Views - содержит исходный код объектов  SwiftUI.
                - Root - основной контейнер UI приложения.
                - Common - переиспользуемые элементы управления.
                - Internal - реализация экранов приложения.
            - Flow - Содержит классы бизнес-логики за пределами UI.
                - Classes
                    - Settings - управлением хранением токена доступа.
                    - Database (для abzV2) - классы поддержки CoreData.
                - Networking - классы поддержки сетевого взаимодействия. В даном проекте только REST.
                    - REST
                        - Base - содержит необходимый перечень классов, для полной реализации REST взаимодействия.
                        - Commands - реализация REST команд (набор отличается для V1 и V2).
            - Resources
                - Assets - содержит экспорт графических ресурсов приложения в формате PDF (векторный формат), иконку приложения (в Figma не представлена, а могла бы быть), а так же, цветовую палитру.
                - Ссылка а настоящий README файл.
        - Project - содержит файл запуска приложения, а так же Info.plist файл необходимый для подачи и получения разрешения на использование камеры устройства.
        
                        
